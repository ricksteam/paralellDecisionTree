<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Canvas</title>
    <link href="style.css" rel="stylesheet" type="text/css">
    <script src="./jquery.js"></script>
    <script src="./jquery.csv.min.js"></script>

    <script type="text/javascript">

        let data;
        let labels = [];
        let variables = [];
        let slots = [];
        function main() {

            $.ajax({
                type: "GET",
                url: "data.csv",
                dataType: "text",
                success: function (response) {
                    data = $.csv.toArrays(response);

                    labels.push("header");
                    labels.push("header");
                    labels.push("header");
                    labels.push("variable");
                    for (let inc = 4; inc < data[0].length; inc++) {
                        labels.push("unknown");
                    }
                    //Figure out the type of each column by scanning each
                    //row for non-empty cells
                    //Find next &

                    for (let row = 0; row < data.length && labels.includes("unknown"); row++) {
                        for (let inc = 0; inc < data[row].length; inc++) {
                            if (labels[inc] != "unknown") continue;

                            let string = data[row][inc].trim();

                            if (string == "") continue;
                            if (string != "&") labels[inc] = "variable_data"
                            else {
                                labels[inc] = "separator";
                                labels[inc + 1] = "variable";
                            }
                        }

                    }

                    for (let col = 0; col < data[0].length; col++) {
                        if (labels[col] == "variable") {
                            for (let row = 0; row < data.length; row++) {
                                let string = data[row][col].trim();
                                if (string != "") {
                                    variables.push({
                                        name: string,
                                        col,

                                    });
                                    break;
                                }
                            }
                        }
                    }

                    for (let i = 0; i < variables.length - 1; i++) {
                        let variable = variables[i];
                        variable.stop = variables[i + 1].col - 1;
                        variable.len = variable.stop - variable.col;
                    }
                    let last = variables.slice(-1)[0];
                    last.stop = data[0].length;
                    last.len = last.stop - last.col;

                    for (let i = 0; i < variables.length; i++) {
                        let variable = variables[i];
                        variable.support = [];
                        variable.rows = [];
                        for (let col = variable.col + 1; col < variable.stop; col++) {
                            variable.support.push([]);
                        }
                        for (let col = variable.col + 1; col < variable.stop; col++) {
                            let index = col - (variable.col + 1);
                            for (let row = 0; row < data.length; row++) {
                                let string = data[row][col].trim();
                                if (string != "to" && string != "is" && string != "<" && string != ">" && string != "<=" && string != ">=" && isNaN(string))
                                    console.log(string);
                                if (string != "") {
                                    if (!variable.rows.includes(row))
                                        variable.rows.push(row);
                                    if (!variable.support[index].includes(string))
                                        variable.support[index].push(string)
                                }
                            }
                        }
                    }

                    for (let i = 0; i < variables.length; i++) {
                        let variable = variables[i];
                        variable.min = Number.MAX_VALUE;
                        variable.max = -Number.MAX_VALUE;
                        variable.allNumbers = [];
                        for (let x = 1; x < variable.support.length; x += 2) {
                            for (let j = 0; j < variable.support[x].length; j++) {
                                let number = parseFloat(variable.support[x][j]);
                                if (number < variable.min) variable.min = number;
                                if (number > variable.max) variable.max = number;
                                if (!variable.allNumbers.includes(number)) variable.allNumbers.push(number);
                            }
                        }
                        variable.marginNumbers = [...variable.allNumbers];
                        variable.marginNumbers.push(variable.min - 1);
                        variable.marginNumbers.push(variable.max + 1);
                        variable.marginMin = variable.min - 1;
                        variable.marginMax = variable.max + 1;

                    }
                    variables.forEach(v => v.marginNumbers = v.marginNumbers.sort());

                    //Now let's see which rows fit into which variable slots
                    slots = [];
                    for (let v = 0; v < variables.length; v++) {
                        let variable = variables[v];
                        let toAdd = [];
                        for (let i = 0; i < variable.marginNumbers.length - 1; i++) {
                            toAdd.push(
                                {
                                    name: variable.name,
                                    min: variable.marginNumbers[i],
                                    max: variable.marginNumbers[i + 1],
                                    rows: []
                                });
                        }
                        slots.push(toAdd);

                    }

                    for (let r = 0; r < data.length; r++) {
                        let row = data[r];
                        for (let v = 0; v < variables.length; v++) {
                            let variable = variables[v];
                            if (!variable.rows.includes(r)) continue;
                            let min = variable.marginMin;
                            let max = variable.marginMax;

                            let one, two;
                            let baseString = row[variable.col + 1].trim();
                            let first = parseFloat(row[variable.col + 2]);
                            if (variable.len == 5) {
                                let second = parseFloat(row[variable.col + 4]);

                                if (baseString == "<") {
                                    one = min;
                                    two = first;
                                }
                                else if (baseString == ">=") {
                                    one = second;
                                    two = max;

                                }
                                else if (baseString == "is") {
                                    one = first
                                    two = second;
                                }
                                else console.error("Error in base string 5")
                            }
                            else if (variable.len == 3) {
                                if (baseString == "<") {
                                    one = min;
                                    two = first;
                                }
                                else if (baseString == ">=") {
                                    one = first;
                                    two = max;
                                }
                                else console.error("Error in base string 3")

                            }
                            else console.error("Error, bad variable length.")

                            //Now update the slots appropriately.
                            let slot = slots[v];
                            for (let i = 0; i < slot.length; i++) {
                                let cell = slot[i];
                                if (one <= cell.min && two >= cell.max)
                                    cell.rows.push(r);
                            }
                        }

                    }






                    console.log(variables);


                    tick();
                }
            });
        }

        function tick() {
            update();
            drawCanvas();
            timerID = setTimeout(tick, 33);
        }


        function update() {
            canvas = document.getElementById("canv");
            canvas.style.width = window.innerWidth + "px"
            canvas.style.height = window.innerHeight + "px"
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        let margin = 100;
        function _mapX(max) {
            return x => (x) / max * (canvas.width - margin * 2) + margin;
        }

        function _mapY(max) {
            return y => (y) / max * (canvas.height - margin * 2) + margin;
        }

        let variable_stop = 2;

        function slotRecurse(slots, i, depth, xMin, xMax, yMin, yMax, ctx) {
            if (depth == 0) {
                let variable = variables[i];
                let slot = slots[i];
                //Draw all the slots at this index;
                let side = i % 4;
                for (let c = 0; c < slot.length; c++) {
                    let cell = slot[c]
                    let globalMin = Math.min(...slot.map(i=>i.min))
                    let globalMax = Math.max(...slot.map(i=>i.max))
                    for (let j = 0; j < cell.rows.length; j++) {
                        let row = data[cell.rows[j]];

                        let lerpX = _mapX(cell.rows.length);
                        let outputNumber = parseFloat(row[1]);
                        let output = outputNumber > .5;
                        
                        let min = cell.min;
                        let max = cell.max;
                        let gap = 10;

                        const lerp = y => (y - globalMin) / (globalMax - globalMin) * (yMax - yMin) + yMin;
                        const xLerp2 = i=>(i)/(cell.rows.length) * (xMax - xMin) + xMin

                        let lerpY = _mapY(cell.rows.length);

                        let one, two;
                        let opacity = .5;

                        ctx.fillStyle = output ? `rgba(0, 200, 0, ${opacity})` : `rgba(200, 0, 0, ${opacity})`;

                        
                        ctx.fillRect(xLerp2(j), lerp(min), (xMax-xMin)/cell.rows.length - gap, lerp(max) - lerp(min));
                    }
                }


            }

        }

        function drawCanvas() {
            var ctx = canvas.getContext("2d");

            ctx.fillStyle = "white";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = "black";
            ctx.strokeRect(margin, margin, canvas.width - margin * 2, canvas.height - margin * 2)


            let variableOrder = [];
            for (let i = 0; i < variables.length; i++) {
                variableOrder.push(i);
            }

            slotRecurse(slots, 0, 0, margin, canvas.width-margin, margin, canvas.height-margin, ctx);

            for (let i = 0; i < variable_stop; i++) {
                let side = i % 4;
                var lerp;

                let variable = variables[variableOrder[i]];
                let min = variable.marginMin;
                let max = variable.marginMax;




                if (side % 2 == 0) {
                    lerp = y => (y - min) / (max - min) * ((canvas.height - margin) - margin) + margin;
                }
                else {
                    lerp = x => (x - min) / (max - min) * ((canvas.width - margin) - margin) + margin;

                }

                const _getX = function (side) {
                    switch (side) {
                        case 0: return () => margin;
                        case 1: return x => lerp(x);
                        case 2: return () => canvas.width - margin;
                        case 3: return x => lerp(x);
                    }
                }

                const _getY = function (side) {
                    switch (side) {
                        case 0: return y => lerp(y);
                        case 1: return () => margin;
                        case 2: return y => lerp(y);
                        case 3: return () => canvas.height - margin;
                    }
                }

                const _getXClose = function (side) {
                    switch (side % 2) {
                        case 0: return () => margin;
                        case 1: return x => lerp(x);
                    }
                }

                const _getYClose = function (side) {
                    switch (side % 2) {
                        case 0: return y => lerp(y);
                        case 1: return () => margin;
                    }
                }

                const _getXFar = function (side) {
                    switch (side % 2) {
                        case 0: return () => canvas.width - margin;
                        case 1: return x => lerp(x);
                    }
                }

                const _getYFar = function (side) {
                    switch (side % 2) {
                        case 0: return y => lerp(y);
                        case 1: return () => canvas.height - margin;
                    }
                }



                const getX = _getX(side);
                const getY = _getY(side);
                const getXClose = _getXClose(side);
                const getXFar = _getXFar(side);
                const getYClose = _getYClose(side);
                const getYFar = _getYFar(side);
                for (let j = 0; j < variable.marginNumbers.length; j++) {

                    ctx.strokeStyle = "black";
                    let marginNumber = variable.marginNumbers[j]

                    ctx.strokeText(marginNumber, getX(marginNumber) - 20, getY(marginNumber));

                    ctx.strokeStyle = "gray";
                    ctx.beginPath();
                    ctx.moveTo(getXClose(marginNumber), getYClose(marginNumber));
                    ctx.lineTo(getXFar(marginNumber), getYFar(marginNumber));

                    ctx.stroke();
                }

                const mapX = _mapX(data.length);




            }

            // for (let i = 0; i < 1; i++) {
            //     let variable = variables[i];
            //     for (let j = 0; j < data.length; j++) {

            //         let lerpX = _mapX(1);
            //         let outputNumber = parseFloat(data[j][1]);
            //         let output = outputNumber > .5;
            //         let row = data[j];

            //         let min = variable.min - 1;
            //         let max = variable.max + 1;
            //         let gap = 10;

            //         const lerp = y => (y - min) / (max - min) * ((canvas.height - margin) - margin) + margin;

            //         let lerpY = _mapY(data.length);

            //         let one, two;
            //         let opacity = 1 / data.length;

            //         ctx.fillStyle = output ? `rgba(0, 200, 0, ${opacity})` : `rgba(200, 0, 0, ${opacity})`;

            //         if (!variable.rows.includes(j)) {
            //             ctx.fillStyle = "yellow";
            //             one = min;
            //             two = max;
            //         }
            //         else {
            //             //Check to see if we have 1 or two entries
            //             let baseString = row[variable.col + 1].trim();
            //             let first = parseFloat(row[variable.col + 2]);
            //             if (variable.len == 5) {
            //                 let second = parseFloat(row[variable.col + 4]);

            //                 if (baseString == "<") {
            //                     one = min;
            //                     two = first;
            //                 }
            //                 else if (baseString == ">=") {
            //                     one = second;
            //                     two = max;

            //                 }
            //                 else if (baseString == "is") {
            //                     one = first
            //                     two = second;
            //                 }
            //                 else console.error("Error in base string 5")
            //             }
            //             else if (variable.len == 3) {
            //                 if (baseString == "<") {
            //                     one = min;
            //                     two = first;
            //                 }
            //                 else if (baseString == ">=") {
            //                     one = first;
            //                     two = max;
            //                 }
            //                 else console.error("Error in base string 3")

            //             }
            //             else console.error("Error, bad variable length.")
            //         }

            //         let screenOne = lerp(one);
            //         let screenTwo = lerp(two);

            //         ctx.fillRect(lerpX(0), screenOne, lerpX(1) - lerpX(0) - gap, screenTwo - screenOne);
            //     }
            // }

            //Now draw the rows



            // let lerpX = mapX(variables.length);
            // let lerpY = mapY(data.length);




            // for (let col = 0; col < variables.length; col++) {
            //     let variable = variables[col];
            //     let x = lerpX(col);
            //     ctx.strokeStyle = "black";
            //     ctx.beginPath();
            //     ctx.moveTo(x, margin);
            //     ctx.lineTo(x, canvas.height - margin);
            //     ctx.stroke();

            //     let text = variable.name.split(".");
            //     for (let i = 0; i < text.length; i++) {
            //         ctx.strokeText(text[i].substr(0, 20), x, 10 + 10 * i);

            //     }

            // }

            // let gap = 10;

            // for (let i = 0; i < data.length; i++) {
            //     let outputNumber = parseFloat(data[i][1]);
            //     let output = outputNumber > .5;
            //     let row = data[i];
            //     let start = lerpY(i);
            //     let stop = lerpY(i + 1);
            //     ctx.beginPath();
            //     ctx.moveTo(margin, start);
            //     ctx.lineTo(canvas.width - margin, start);
            //     ctx.moveTo(margin, stop - gap);
            //     ctx.lineTo(canvas.width - margin, stop - gap);
            //     ctx.stroke();

            //     //Now lay down the actual data

            //     for (let v = 0; v < variables.length; v++) {
            //         let variable = variables[v];

            //         //Write the variables
            //         ctx.strokeText(variable.min - 1, lerpX(v), start);
            //         ctx.strokeText(variable.max + 1, lerpX(v), stop - gap);

            //         let min = variable.min - 1;
            //         let max = variable.max + 1;

            //         const lerp = y => (y - min) / (max - min) * ((stop - gap) - start) + start;

            //         let one, two;


            //         ctx.fillStyle = output ? "green" : "red";

            //         if (!variable.rows.includes(i)) {
            //             ctx.fillStyle = "yellow";
            //             one = min;
            //             two = max;
            //         }
            //         else {
            //             //Check to see if we have 1 or two entries
            //             let baseString = row[variable.col + 1].trim();
            //             let first = parseFloat(row[variable.col + 2]);
            //             if (variable.len == 5) {
            //                 let second = parseFloat(row[variable.col + 4]);

            //                 if (baseString == "<") {
            //                     one = min;
            //                     two = first;

            //                 }
            //                 else if (baseString == ">=") {
            //                     one = second;
            //                     two = max;

            //                 }
            //                 else if (baseString == "is") {
            //                     one = first
            //                     two = second;

            //                 }
            //                 else {
            //                     console.log("Error in base string 5")
            //                 }
            //             }
            //             else if (variable.len == 3) {
            //                 if (baseString == "<") {
            //                     one = min;
            //                     two = first;

            //                 }
            //                 else if (baseString == ">=") {
            //                     one = first;
            //                     two = max;

            //                 }

            //                 else {
            //                     console.log("Error in base string 3")
            //                 }
            //             }
            //             else {
            //                 console.log("Error, bad variable length.")
            //             }
            //         }

            //         let screenOne = lerp(one);
            //         let screenTwo = lerp(two);

            //         ctx.fillRect(lerpX(v), screenOne, 10, screenTwo - screenOne);
            //     }

            // }
        }
    </script>
</head>

<body onload="main()">
    <canvas id="canv"></canvas>
</body>

</html>